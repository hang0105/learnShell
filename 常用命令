1	文件管理
【cat命令】
 用来把文档串联后传到基本输出 
【实例 | 技巧】
cat -n file1 > file2                   # 将file1加编号后输出到file2
cat -b file1 file2 >> file              # 给两文件加编号后后追加输出到file
cat /dev/null > /tmp/test.log         # 清空test.log文件
cat > newfile                        # 创建新文件， 输入内容并用Ctrl+D退出
cat /OSM/log/cur_debug/messages | more    # 用分页的方式来显示文件内容, 按Q键退出
 
【归纳 | 总结】
【总结一】:cat的四个主要功能
(1) 用来显示文件内容，内容多的话，与more, less配合使用 cat messages | more
(2) 用来创建一个新文件cat > newfile
(3) 用来合并多个文件cat -b file1 file2 > file
(4) 用来清空文件cat /dev/null > /tmp/test.txt
【总结二】:cat与tac命令区别
tac命令是cat的反写，功能也相反，是将文件从最末一行到第一行开始显示
	tac /etc/passwd
	cat /etc/passwd
【more命令】
 用来一页一页翻动阅读
【实例 | 技巧】
more file               # 分页的方式显示file文件
more -s file            # 碰到有两行以上的空格，以一行来显示
more +20 file          #  从第20行开始显示内容
cat file | more         # 与其他命令组合使用
【归纳 | 总结】
【备注一】more命令常用操作 :
	空格键(space)  表示向下翻一页
	Enter键        表示向下翻一行
	/str           表示向下搜索字符串"str"   
	:f             立刻显示文件名以及当前显示的行数
	q             离开  
【less命令】
 用来一页一页翻动阅读，但用法比more更灵活 
【实例 | 技巧】
less /etc/man.config         # 常用用法
less file1 file2                #  同时显示两个文件
ps -ef | less                  # ps查看进程信息并以less分页显示
history | less                 # 用分页方式来显示history的内容
【归纳 | 总结】
【备注一】less命令常用操作 :
空格键        向下翻动一页
[pagedown]  向下翻动一页
[pageup]     向上翻动一页
/str          向下搜索"str" 
?str          向上搜索"str"   
n            重复前一个搜索(与/或?有关) 
N            反向重复前一个搜索(与/或者?有关) 
q            离开less命令
【tail命令】
 用来强制获取文件新增的内容
【实例 | 技巧】
tail -f /OSM/log/cur_debug/messages       # 监控messages文件尾部内容，默认10行
tail -n 20 /OSM/log/cur_debug/messages   # 显示文件messeages最后20行
tail -n +10 2015.log                        # 从第10行开始显示2015.log文件的内容
【归纳 | 总结】
【备注一】tail命令的几点说明 :
(1) 该命令主要用来查看一个正在生产的文件是否有我们要找的关键字
(2) 主要参数就是-f, 也可连起来写: tailf /OSM/log/cur_debug/messages
【tee命令】
 用来从标准输入中读取数据，并输出到标准输出设备
【实例 | 技巧】
echo "Hello,World" | tee out.txt       # tee out.txt  覆盖文件
echo 12345 | tee -                   # 比对结果，tee -输出到标准输出两次
history | tee history1 history2        # 输出history的执行结果，同时保留两份输出文件
ls -lart | tee -a file.txt | cat -n         # tee -a file.txt 追加的方式保存文件
ls -l * 2&>1 | tee -a out.txt           # 标准输出，标准错误均被tee读取
ls -lR /etc/ | tee A1.out | sort | tee A2.out | sort -r | tee A3.out | uniq -c | tee A4.out > A5.out
【归纳 | 总结】
【备注一】为什么在shell中要用tee命令
某些命令运行的结果会很长，你可能会用less 来上下看。再或者你可能会用>来重定向到文件里。但某些时候程序有可能需要你输入 y 来确认，或者某些程序运行的时间很长，仅仅重定向的话又不太确定是不是它在正常运行。tee 就能做到又输出到屏幕上，又同时重定向到文件。在Shell脚本中很常用
 
【chattr命令】
 用来设置ext2/ext3文件隐藏属性  
【实例 | 技巧】
chattr +i /etc/passwd         # 防止某个关键文件被修改
chattr -i /etc/passwd          # 关闭该文件的i属性
chattr +a /var/log/messages   # 只能添加数据，不能删除，常用于日志文件
【归纳 | 总结】
【备注一】关于chattr命令的几点说明:
(1) 该命令在系统数据安全方面非常重要，chattr命令最常用的属性就是a和i
(2) chmod只改变文件的读写、执行权限，更底层的属性是由chattr来改变的
(3) 如果用root账号还不能修改文件，就要考虑是否被锁定了，也就是chattr命令
(4) chattr命令并不适合所有的目录。该不能保护/、/dev、/tmp、/var目录
【lsattr命令】
 用来显示文件隐藏属性 
【实例 | 技巧】
lsattr -aR /etc                         # 列出该文件的属性
lsattr /etc/passwd /etc/shadow        # 拿两个文件的属性显示出来
【归纳 | 总结】
【备注一】关于lsattr命令的几点说明:
(1) 如果用root账号还不能修改文件，就要考虑是否被锁定了，就要用lsattr命令
(2) 如果看到Operation not permitted报错， 就要考虑chattr,lsattr两个命令了
【find命令】
 用来在指定目录下查找文件
【实例 | 技巧】
find . -name "*.sh"  # 在当前目录及其子目录下，拿所有的sh文件找出来
find . -ctime -30     # 将当前目录及其子目录下，最近半小时内创建的文件列出
find $HOME -type f -size 0 -exec ls -l {} \;   #  查找主目录中所有空文件找出来，并列出
find . -type f -perm 644 -exec ls -l {} \;       # 查找权限符合的并列出
find /tmp -iname "*.log" | xargs -n50 grep "ERROR"  # xargs执行结果，iname忽略大小写
find . -name "[A-Z]*" -print file     # 当前目录下查找大写字母开头文件，并将其输出到file文件
find . -newer 2013.log ! -newer 2015.log  # 查找比第一个文件新，但比第二个文件旧的文件
find /etc /root ! -user root -mtime -2 -print # 查找这两个文件夹，非root创建,2天内有访问的文件
find ~ -maxdepth 2 -empty -not -name ".*" # 查找家目录及下一级目录下非隐藏空文件
find / -type f -exec ls -s {} \; | sort -n -r | head -5  # 查找系统中最大5个文件
find . -not -empty -type f -exec ls -s {} \; | sort -n  | head -5  # 当前目录下找非空最小的5个文件
find / -type f -name *.tmp -size +100M -exec rm -i {} \;"  # 查找100M以上tmp文件并删除
find . -perm 777 -print | xargs chmod –x  # 查找当前目录下权限为777，并去掉可执行权限
find . \( -name a.out -o -name '*.o' -o -name 'core' \) -exec rm {} \; # 清除c语言产生的临时文件
find . -type f -mtime +30 -name "*.log" -exec cp {} old \;  # 将30天前的空文件移到old目录下
find /tmp -name "^[0-9]{4}[AB].sh"  # 正则表达式运用, 2015A.sh或2014B.sh
find /tmp -name "*.sh" -exec cp {} {}.bak \; # 注意{}的运用
find . -name ".svn" -exec rm -rf {} \;   #  很常用的一个应用
find . -regex ‘.*/[0-9]\w.*’         # 匹配以数字开头的文件
【归纳 | 总结】
【备注一】关于find命令的几点说明:
	-exec command {} \;   # {}与\之间有空格，以;结束, 将查询到的结果执行command操作
	-exec 与 -ok 效果一样，只是多个提示，一种更安全，更友好的方式
	UNIX/Linux文件系统每个文件都有三种时间戳： 
访问时间（-atime/天，-amin/分钟）：用户最近一次访问时间。 
修改时间（-mtime/天，-mmin/分钟）：文件最后一次修改时间。 
变化时间（-ctime/天，-cmin/分钟）：文件数据元（例如权限等）最后一次修改时间。
(4)  类型参数列表： f 普通文件 l 符号连接 d 目录 c 字符设备 b 块设备 s 套接字 p Fifo
【备注二】find命令结合正则表示式使用示例:
 
【locate命令】
 用来查找符合条件的文档，根据数据库模糊匹配  
【实例 | 技巧】
locate passwd                # 查找passwd文件
locate -u                     # 手工升级数据库，一般是系统自动维护，更新的频率为每天
【归纳 | 总结】
【备注一】关于locate的几点说明:
(1) locate会去保存文档和目录名称的数据库内，查找合乎条件的文档或目录
(2) locate命令预设的数据库位于/var/lib/slocate目录里，文档名为slocate.db
(3) locate内容一般每日更新一次，也可locate -u 或updatedb来手工更新
【总结一】locate与find区别:
locate与find是查找文件中应用最频繁的。两者不同: find 是去硬盘找，locate 只在/var/lib/slocate资料库中找。locate的速度比find快，它并不是真的查找，而是查数据库，一般文件数据库在/var/lib/slocate/slocate.db中，所以locate的查找并不是实时的，而是以数据库的更新为准，一般是系统自己维护，也可以手工升级数据库
【总结二】find, which,whereis,locate区别:
(1) find 是直接在硬盘上搜寻，功能强大，但耗硬盘，一般不要用。常用于Shell脚本.
(2) which只能查可执行文件和别名, 并在PATH变量中查找
(3) whereis只能查二进制文件、说明文档，源文件等
(4) locate和whereis都是查数据库/var/lob/slocate/slocate.db里的内容。比find快
【which命令】
 用来查找可执行文件位置 
【实例 | 技巧】
which pwd                # 找出pwd的绝对路径
which grep cut ls          # 查看多条命令， 一同显示
【归纳 | 总结】
【备注一】关于which命令的几点说明:
	which命令的基本功能是查找可执行文件，主要是搜索命令所在目录
	whereis命令不仅能搜索命令所在目录，还能搜索其帮助文档存储路径
	whatis命令可以显示命令的简短信息，能够做什么用
	/sbin和/usr/sbin主要放root用户命令
	/bin和/usr/bin主要放置普通用户命令
【whereis命令】
 用来查找符合条件的源代码、二进制文件、帮助文件 
【实例 | 技巧】
whereis -b bash    # 只查找二进制文件路径
whereis -m bash   # 只查找说明文件
【归纳 | 总结】
【备注一】关于whereis命令的几点说明:
(1)	whereis也是搜索/var/lib/slocate/slocate.db数据库，相比find而言，速度快
(2)	whereis与locate的区别在于:前者精确匹配，后者模糊查找，列出一串结果
【总结一】whereis执行结果说明:
(1) whereis的执行结果: whereis bash
bash:/bin/bash  /etc/bash.bashrc  /usr/share/man/man1/bash.1.gz
以上输出信息从左至右分别为查询的程序名、bash路径、bash的man手册页路径
(2) 可以手工执行/usr/bin/updatedb命令来更新数据库
【cksum命令】
 用来检查文件的CRC是否正确   
【实例 | 技巧】
cksum A.tgz                # 计算A.tgz包的CRC
cksum /bin/* > /bin.cksum  # 一旦/bin该目录下有任何文件改动，bin.cksum就会改动
【归纳 | 总结】
【备注一】关于cksum命令的几点说明:
(1) CRC校验的标准由CCITT所指定，至少可检测出99.998%的已知错误
(2) 经cksum进行校验后，该指令会返回校验结果供用户核对文件是否正确无误
(3) 若指定的文件名为"-"， 则指令chsum会从标准输入中读取数据
(4) 这个测试要求校验在源文件中和目的文件中各计算一次，然后比对两次校验结果
(5) cksum(check and sum循环冗余) 和 md5sum(计算md5)用法类似
【备注二】chsum, md5sum, sha1sum命令的主要用途:
	用途一: 确保文件从一个系统传输到另一个系统地过程中没有被损坏
	用途二: 检查文件或目录是否被改动过
【总结一】cksum, md5sum, sha1sum:
	cksum：计算文件的CRC校验码(循环冗余校验码)和字节数，使用较少
	md5sum：计算和检查md5值；主要用于生成指纹，使用的比cksum多
	sha1sum: 和md5sum都可用于哈希校验,加密效果更好一点,md5sum使用得更为广泛
【dos2unix命令】
 用来将DOS格式的文本文件转换为UNIX格式
【实例 | 技巧】
dos2unix file                          # 转单个文本文件， 注意:可执行文件不用转换
dos2unix file1 file2 file3                # 一次行转换多个文件
dos2unix -k file                        #  保留源文件的时间戳
dos2unix -n old_file  new_file         # 保留源文件，输出新文件
cat test.txt | tr -d '\r' | cat -v           # 通过tr来删除, -v参数能显示^M字符
cat  test.txt | sed  's:\r::' | cat -v      # 通过sed来删除
dos2unix *.sh                        #  同类型的.sh脚本批量转
find . -type f -exec dos2unix {} \;      # 多种文本文件，如何进行全部转换
【归纳 | 总结】
【备注一】为什么要用dos2unix
Windows和Linux中文件的换行符的不同，导致文件间的一些兼容问题，Windows系统中用/r/n来表示换行，Linux中用/n来表示换行，Windows的文本文件，直接到Linux中使用可能会出错，因为多出了“/r”字符，具体表现就是每行后面有个字符^M，通过dos2unix 来将window的文本文件转换来适应Linux
【总结一】dos2unix与unixtodos
(1)	dos2unix: 将Windows下的文件转成适应Linux系统的文件
(2)	unix2dos: 将Linux下的文件转成适应Windows系统的文件
(3)	用法一致:  unix2dos filename
(4)	备注: 目前阵列上没有unix2dos命令
【file命令】
 　用来辨识文件类型 
【实例 | 技巧】
file install.log               # 显示该文件的文件类型
file -L /var/mail             # 显示连接文件指向文件的类型
file /etc/*                   # 显示/etc目录下所有文件的文件类型
file -s /dev/sd-[0-9][0-9]a    # 检查块文件，获取文件系统信息
【归纳 | 总结】
【备注一】Linux中的文件类型: 
(1) 普通文件: 纯文本文件(ascii)，二进制文件(binary)，数据格式文件(data)
(2) 目录文件(第一个字符为d的，类似于: drwxr-xr-x)
(3) 字符设备和块设备(第一个字符为b, 比如ls -l /dev/sda, 第一个字符为c，字符设备)
(4) 套接字文件(第一个字符为s，比如:mysql.sock)
(5) 符号连接文件(第一个字符为l, 比如ls -l /var/mail)
(6) 管道文件(FIFO, first in first out)
【总结一】file命令作用:
file命令的作用是用于检验文件的类型，并打印至终端。主要按以下顺序来完成：
(1) 检验文件系统中支持的文件类型。
(2) 检验magic file规则(如C文件，它会有#include字样；tar文件的前几个字节会有特殊的规则)
(3) 检验文件内容的语言和字符集
【umask命令】
 用来设定权限掩码，默认权限-权限掩码 = 预设权限 
【实例 | 技巧】
umask              # 获取当前的权限掩码, 0022，第一位是GID/UID，022(ugo)
umask -S           # 以文字的方式来显示，比如说: u=rwx, g=rx, o=rx
umask 002        # 拿others的权限属性去掉写(w)的权限
【归纳 | 总结】
【备注一】关于umask命令的几点说明:
(1) 默认用户建立的文件的权限: 666(-rw-rw-rw)， 即没有执行的权限
(2) 默认用户建立的目录的权限: 777(drwxrwxrwx)
(3) 两个权限减去umask设置的权限掩码，就能得出文件和目录的实际权限
(4) 基于安全方面的考虑，root的默认umask是022, 该设置可参考/etc/bashrc内容
(5) 想更改整个系统全部默认的umask值，可以更改/etc/profile，一般不建议改
【扩展 | 引申】
【引申一】按照字符的方式来计算umask值:
假如umask设置为003（即去掉others的写+执行权限）
比如说: 默认文件权限666-003=663即others还具备wx权限，这是错误的。
正确的计算:
文件: (-rw-rw-rw-) - (-------wx)  = -rw-rw-r--
目录: (drwxrwxrwx) - (-------wx) = drwxrwxr--
【touch命令】
 用来修改文件时间属性或创建空文件  
【实例 | 技巧】
touch file             # 修改file文件的时间为系统时间，若file不存在，则创建新文件
touch /etc/nologin    # 系统维护期间禁止用户登录，但不限于SSH登录
touch -c -t 201511301130.45 file  # 设定文件的时间戳, 不存在则不创建新文件
touch -r /etc/passwd file          # 将后者的时间戳设置为前面的一样
touch -a text                     # 修改文件的访问时间
touch -d "11/30/2015" *.sh        # 统一修改shell脚本的时间戳为2015/11/30
touch -d "10:18am 11/30/2015" text    # 2015年11月30日 上午10点18分
touch file1 file2 file3                   #  同时创建多个文件
touch -d "2 days ago" /etc/passwd     # 同样可以修改时间
find /var -name * -exec touch {} \;      # 若发现系统文件时间都不对了，统一修改
【归纳 | 总结】
【备注一】-t选项的时间格式[[CC]YY]MMDDhhmm[.ss]说明:
CC   表示世纪
YY   表示年
MM  表示月
DD   表示日
hh   表示小时
mm  表示分钟
ss    表示秒    
比如: 201510281200.35  世纪20可有可无
【总结一】touch命令的两个主要用途:
主要用来创建新文件和修改创建时间
(1) touch命令最主要用在创建新的空文件， 且用户必须拥有该目录下的写权限
(2) 可以用默认当前时间来更新文件的访问时间和修改时间，也可以指定参数来更新
【mkdir命令】
 用来创建空目录 
【实例 | 技巧】
mkdir emptydir                # 创建空目录文件
mkdir dir1 dir2 dir3 dir4       # 同时创建多个目录
mkdir -m 770 download       # 权限设置为u,g可读、写、执行，others无权访问
mkdir -p dir1/dir2/dir3        # 递归创建多个目录，若dir1不存在，必须加-p参数
mkdir -p /root/dir1/dir2/dir3   # 上例以相对路径，本例以绝对路径来创建目录
mkdir -m=r-- dir1             # 创建并设置主，组，其他用户只只有读权限的目录
【归纳 | 总结】
【备注一】rmdir
rmdir是remove directory的缩写; mkdir的反操作 rmdir -p dir1/dir2/dir3
【备注二】一次性创建指定权限的工程目录实例
 
【rm命令】
 用来删除一个文件或目录 
【实例 | 技巧】
rm -i file      # 在删除file文件时，先确认
rm -f *.c      # 强制删除所有后缀为.c的文件
rm -rf /test    # 强制递归删除/test目录下的所有子目录及文件
【归纳 | 总结】
【备注一】关于rm的几点说明:
(1) 为安全起见，很多Linux版本默认有-i参数
(2) 如果确定目录不要了，可以使用rm -rf来循环删除
(3) 有时使用了参数 -f，但仍然会询问是否覆盖某文件，这是因为某些服务器，会默认增加别名 alias rm='rm -i',当执行cp操作时，实际执行的是 rm -i，该问题可以这样解决： vi ~/.bashrc,在alias rm='rm -i'前使用#注释掉即可
【备注二】运用mv命令批量修改文件后缀示例:
比如我们要批量修改后缀为.py的文件为，这个时候就需要用到mv命令
 

 
【mv命令】
 　用来做文件名或目录更名，或将其移动位置 
【实例 | 技巧】
mv 2014.log 2015.log                  # 文件重命名，也是最常用的, 最好加i参数
mv -t /tmp 2013.log 2014.log 2015.log  # 将三个文件移动到/tmp，注意目标文件放前面
mv -v 2013.log 2014.log 2015.log /tmp  # 效果同上, 显示详细执行过程
mv dir1 dir2             # 若dir2不存在，则将dir1命名；若已存在，则dir1下文件移动到dir2中
mv -b file1 file2          # 若file2存在，在改名前会先备份，备份的文件名为file2~
mv -i 2014.log 2015.log    # 将文件file1改名为file2，如果file2已经存在，则询问是否覆盖
mv -u file1 file2            # file1比file2新则更新，否则更新失败
【归纳 | 总结】
【备注一】关于mv命令的几点说明:
(1) Linux中覆盖和重命名的概念几乎是一样的，没有Windows中所谓的rename这一说法
(2) 选项可以写在任意位置，可以mv f1 -v f2，也可以mv -v f1 f2，还可以mv f1 f2 -v
【cp命令】
 　用来Linux服务器内复制文件或目录   
【实例 | 技巧】
cp ~/.bash_history /tmp/history    # 拷贝文件到/tmp目录下，并重命名
cp /etc/file1 /etc/file2 /etc/file3  .  #  多文件拷贝文件到当前目录
cp  -r /etc /tmp                   # 递归复制
cp -a /var/log/wtmp wtmp_1       # 拷贝wtmp文件到本地，并保留所有属性
cp -s wtmp wtmp_slink             # 对wtmp文件建一个快捷方式
cp -l wtmp wtmp_hlink             #  建硬连接文件
cp -i /etc/passwd passwd          # 源文件存在，拷贝之前会先询问
cp -u ~/.bashrc  /tmp/bashrc     # 目标文件比源文件旧才更新，常用于shell脚本
【归纳 | 总结】
【备注一】拷贝时先要搞清楚下面几个问题:
(1) 是否需要完整保留源文件的信息
(2) 源文件是否为连接文件
(3) 源文件是否为目录，如为目录，要用-r或-R参数
PS: 拷贝时为防覆盖最好用-i参数提醒，或加个别名alias cp='cp -i'
【scp命令】
 　用来Linux服务器之间复制文件或目录
【实例 | 技巧】
【从本地复制到远端 】scp 本地文件  远端用户@远端IP:远端文件夹
scp /home/permitdir/A.tgz  admin@129.7.230.74:/home/permitdir/
【从远端复制到本地】 scp 远端用户@远端IP:远端文件夹  本地文件
scp -r admin@129.7.230.74:/home/permitdir/  /tmp/    # 递归拷贝目录
【归纳 | 总结】
【备注一】关于scp命令的几点说明:
(1)	如远程服务器有为scp命令设置了指定的端口，需用-P参数设置命令的端口号 
scp -P 1234 remote@server:/usr/local/sin.sh /home/administrator
(2) 用户必须具有可读取远程服务器相应文件的权限，否则scp命令是无法起作用的
(3) 一般能ssh就能执行scp的操作，它们用到时同一个端口，防火墙默认是打开的
# iptables -I　INPUT -p tcp --dport 22 -j ACCEPT
【备注二】cp和scp区别:
(1) cp和scp前者是服务内部的拷贝，后者是服务器之间的拷贝, 比FTP安全
(2) cp是copy的简写，是Linux服务器内部不同目录之间的复制
(3) scp是Linux服务器基于SSH登录并进行安全的远程文件拷贝命令
